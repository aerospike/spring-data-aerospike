[[aerospike.object-mapping]]
= Aerospike Object Mapping

Rich mapping support is provided by the `AerospikeMappingConverter`. `AerospikeMappingConverter` has a rich metadata model that provides a full feature set of functionality to map domain objects to Aerospike clusters and objects.The mapping metadata model is populated using annotations on your domain objects. However, the infrastructure is not limited to using annotations as the only source of metadata information. The `AerospikeMappingConverter` also allows you to map objects without providing any additional metadata, by following a set of conventions.

In this section, we will describe the features of the `AerospikeMappingConverter`, how to use conventions for mapping objects to documents and how to override those conventions with annotation-based mapping metadata.

For more details refer to SpringData documentation:
<<mapping.fundamentals, Object Mapping>>.

[[mapping-conventions]]
== Convention Based Mapping

`AerospikeMappingConverter` has a few conventions for mapping objects to documents when no additional mapping metadata is provided. The conventions are:

[[mapping-conventions-id-field]]
=== How the 'id' Field Is Handled in the Mapping Layer

Aerospike DB requires that you have an `id` field for all objects. The `id` field can be of any primitive type as well as `String` or `byte[]`.

The following table outlines the requirements for the `id` field:

[cols="1,2", options="header"]
.Examples for the translation of '_id'-field definitions
|===
| Field definition
| Description

| `String` id
| A field named 'id' without an annotation

| `@Field` `String` id
| A field annotated with `@Id` (`org.springframework.data.annotation.Id`)

| `@Id` `String` customNamedIdField

|===

The following description outlines what type of conversion, if any, will be done on the property mapped to the `id` document field:

* By default, the type of the field annotated with `@id` is turned into a `String` to be stored in Aerospike database.
If the original type cannot be persisted (see xref:#configuration.keep-original-key-types[keepOriginalKeyTypes]
for details), it must be convertible to `String` and will be stored in the database as such,
then converted back to the original type when the object is read. This is transparent to the application
but needs to be considered if using external tools like `AQL` to view the data.
* If no field named "id" is present in the Java class then an implicit '_id' file will be generated by the driver but not mapped to a property or field of the Java class.

When querying and updating `AerospikeTemplate` will use the converter to handle conversions of the `Query` and `Update` objects that correspond to the above rules for saving documents so field names and types used in your queries will be able to match what is in your domain classes.

[[mapping-configuration]]
== Mapping Configuration

Unless explicitly configured, an instance of `AerospikeMappingConverter` is created by default when creating a `AerospikeTemplate`. You can create your own instance of the `MappingAerospikeConverter` so as to tell it where to scan the classpath at the startup of your domain classes in order to extract metadata and construct indexes.
Also, to have more control over the conversion process (if needed), you can register converters to use for mapping specific classes to and from the database.

NOTE: AbstractAerospikeConfiguration will create an AerospikeTemplate instance and register with the container under the name 'AerospikeTemplate'.

[[mapping-usage-annotations]]
=== Mapping Annotation Overview

The MappingAerospikeConverter can use metadata to drive the mapping of objects to documents using annotations. An overview of the annotations is provided below

* `@Id` - applied at the field level to mark the field used for identity purposes.
* `@Field` - applied at the field level, describes the name of the field as it will be represented in the AerospikeDB BSON document thus allowing the name to be different from the field name of the class.
* `@Version` - applied at the field level to mark record modification count. The value must be effectively integer.
In Spring Data Aerospike, documents come in two forms – non-versioned and versioned.
Documents with an `@Version` annotation have a version field populated by the corresponding record’s generation count.
Version can be passed to a constructor or not (in that case it stays equal to zero).
* `@Expiration` - applied at the field level to mark a property to be used as expiration field.
Expiration can be specified in two flavors: as an offset in seconds from the current time (then field value must be
effectively integer) or as an absolute Unix timestamp. Client system time must be synchronized
with Aerospike server system time, otherwise expiration behaviour will be unpredictable.

The mapping metadata infrastructure is defined in a separate spring-data-commons project that is technology-agnostic. Specific subclasses are used in the AerospikeDB support to support annotation-based metadata. Other strategies are also possible to put in place if there is demand.

Here is an example of a more complex mapping.

[source,java]
----
public class Person<T extends Address> {

  @Id
  private String id;

  private Integer ssn;

  @Field("fName")
  private String firstName;

  private String lastName;

  private Integer age;

  private Integer accountTotal;

  private List<Account> accounts;

  private T address;

  @Version
  private int id; // must be integer

  public Person(Integer ssn) {
    this.ssn = ssn;
  }

  public Person(Integer ssn, String firstName, String lastName, Integer age, T address, int version) {
    this.ssn = ssn;
    this.firstName = firstName;
    this.lastName = lastName;
    this.age = age;
    this.address = address;
    this.version = version;
  }

  public String getId() {
    return id;
  }

  // no setter for Id.  (getter is only exposed for some unit testing)

  public Integer getSsn() {
    return ssn;
  }

// other getters/setters omitted
}
----
