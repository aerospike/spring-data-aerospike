[[aerospike.object-mapping]]
= Aerospike Object Mapping

Rich mapping support is provided by the `AerospikeMappingConverter` which has a rich metadata model that provides a full feature set of functionality to map domain objects to Aerospike objects. The mapping metadata model is populated using annotations on your domain objects.
However, the infrastructure is not limited to using annotations as the only source of metadata information.
The `AerospikeMappingConverter` also allows you to map objects without providing any additional metadata, by following a set of conventions.

In this section, we will describe the features of the `AerospikeMappingConverter`, how to use conventions for mapping objects to documents and how to override those conventions with annotation-based mapping metadata.

For more details, refer to Spring Data documentation:
link:https://docs.spring.io/spring-data/commons/reference/object-mapping.html[Object Mapping].

[[mapping-conventions]]
== Convention Based Mapping

`AerospikeMappingConverter` has a few conventions for mapping objects to documents when no additional mapping metadata is provided.
The conventions are:

[[mapping-conventions-id-field]]
=== How the 'id' Field Is Handled in the Mapping Layer

Aerospike DB requires that you have an `id` field for all objects.
The `id` field can be of any primitive type as well as `String` or `byte[]`.

The following table outlines the requirements for the `id` field:

[cols="1,2",options="header"]
.Examples for the translation of '_id'-field definitions
|===
| Field definition
| Description

| `String` id
| A field named 'id' without an annotation

| `@Id` `String` myId
| A field annotated with `@Id` (`org.springframework.data.annotation.Id`)

|===

The following description outlines what type of conversion, if any, will be done on the property mapped to the `id` document field:

* By default, the type of the field annotated with `@id` is turned into a `String` to be stored in Aerospike database.
If the original type cannot be persisted (see xref:#configuration.keep-original-key-types[keepOriginalKeyTypes]
for details), it must be convertible to `String` and will be stored in the database as such, then converted back to the original type when the object is read.
This is transparent to the application but needs to be considered if using external tools like `AQL` and the Aerospike JDBC Driver to view the data.
* If no field named "id" is present in the Java class then an implicit '_id' file will be generated by the driver but not mapped to a property or field of the Java class.

When querying and updating `AerospikeTemplate` will use the converter to handle conversions of the `Query` and `Update` objects that correspond to the above rules for saving documents so field names and types used in your queries will be able to match what is in your domain classes.

[[mapping-configuration]]
== Mapping Configuration

Unless explicitly configured, an instance of `AerospikeMappingConverter` is created by default when creating a `AerospikeTemplate`.
You can create your own instance of the `MappingAerospikeConverter` so as to tell it where to scan the classpath at the startup of your domain classes in order to extract metadata and construct indexes.
Also, to have more control over the conversion process (if needed), you can register converters to use for mapping specific classes to and from the database.

NOTE: AbstractAerospikeConfiguration will create an AerospikeTemplate instance and register with the container under the name 'AerospikeTemplate'.

[[mapping-usage-annotations]]
=== Mapping Annotation Overview

The MappingAerospikeConverter can use metadata to drive the mapping of objects to documents using annotations.
An overview of the annotations is provided below

* `@Id` - applied at the field level to mark the field used for identity purposes.
* `@Field` - applied at the field level, describes the name of the field as it will be represented in the AerospikeDB BSON document thus allowing the name to be different from the field name of the class.
* `@Version` - applied at the field level to mark record modification count.
The value must be effectively integer.
In Spring Data Aerospike, documents come in two forms – non-versioned and versioned.
Documents with an `@Version` annotation have a version field populated by the corresponding record’s generation count.
Version can be passed to a constructor or not (in that case it stays equal to zero).
* `@Expiration` - applied at the field level to mark a property to be used as expiration field.
Expiration can be specified in two flavors: as an offset in seconds from the current time (then field value must be effectively integer) or as an absolute Unix timestamp.
Client system time must be synchronized with Aerospike server system time, otherwise expiration behaviour will be unpredictable.

The mapping metadata infrastructure is defined in a separate spring-data-commons project that is technology-agnostic.
Specific subclasses are used in the AerospikeDB support to support annotation-based metadata.
Other strategies are also possible to put in place if there is demand.

Here is an example of a more complex mapping.

[source,java]
----
public class Person<T extends Address> {

  @Id
  private String id;

  private Integer ssn;

  @Field("fName")
  private String firstName;

  private String lastName;

  private Integer age;

  private Integer accountTotal;

  private List<Account> accounts;

  private T address;

  @Version
  private int id; // must be integer

  public Person(Integer ssn) {
    this.ssn = ssn;
  }

  public Person(Integer ssn, String firstName, String lastName, Integer age, T address, int version) {
    this.ssn = ssn;
    this.firstName = firstName;
    this.lastName = lastName;
    this.age = age;
    this.address = address;
    this.version = version;
  }

  public String getId() {
    return id;
  }

  // no setter for Id.  (getter is only exposed for some unit testing)

  public Integer getSsn() {
    return ssn;
  }

// other getters/setters omitted
}
----

[[mapping-parameter-name-known-issue]]
=== Troubleshooting "Parameter Does Not Have a Name": Known Issue

Let's assume we have a complex entity called `Person`. In order to get a smaller subset of fields (only `firstName`, `lastName` and `email`) from `Person` object we want to run a simple `find` query using DTO projection, so we create a DTO entity called `PersonSomeFields`:

[source,java]
----
@Data
@Builder
public class PersonSomeFields {

    private String firstName;
    private String lastName;
    @Field("email")
    private String emailAddress;
}

List<PersonSomeFields> result = repository.findPersonSomeFieldsByFirstName("Carter");
----

However, when we run this query, it might lead to a `MappingException` with the message "Parameter %s does not have a name".

When mapping to a DTO / entity class like `PersonSomeFields` (often annotated with Lombok's `@Data` and `@Builder`), Spring Data attempts to create an instance of `PersonSomeFields`. During this process, it tries to identify the constructor parameters and their corresponding property names.

Without a no-argument constructor explicitly defined or generated, Spring Data attempts to use the implicitly generated constructor. To correctly map constructor parameters to entity properties, it relies on the parameter names being available at runtime. However, Java compiler or Lombok's generated constructors often do not retain parameter names, leading to `null` being returned for parameter name.

The solution is to ensure that Spring Data has a way to instantiate the `PersonSomeFields` class without relying on extracting parameter names from a constructor that might not have them available at runtime. The simplest and most robust way to achieve this is by providing a no-argument constructor.

When using Lombok, this is easily done by adding the `@NoArgsConstructor` annotation to your DTO class. This instructs Lombok to generate a public no-argument constructor.

If you are using `@Builder` alongside `@NoArgsConstructor`, it's typically required by Lombok to also include `@AllArgsConstructor`.

Here is an example of the modified class:

[source,java]
----
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PersonSomeFields {

    private String firstName;
    private String lastName;
    @Field("email")
    private String emailAddress;
}
----

