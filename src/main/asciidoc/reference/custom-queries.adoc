= Custom Queries

[[custom-queries-intro]]
== Introduction

Regular repository queries are obviously helpful for most of the querying tasks. Each of the repositories adds more functionality by providing its query methods.

There are some cases, however, when data finding tasks require building query methods which are more complex, more flexible or unsupported in a standard repository. Custom queries is such a special mechanism in Spring Data Aerospike. Currently only finding (reading) queries are supported.

[[find-using-query]]
== Find Using Query

User can perform a custom `Query` using a special custom `Qualifier` which represents an expression.
It may contain other qualifiers and combine them using either `AND` or `OR`, with some limitations due to Qualifier type.

Custom `Qualifier` can be created for queries of the following types: regular (Aerospike bins), metadata, DSL expression, indexed with expression and ids (primary keys).
Below are examples for the mentioned custom queries types.

[[custom-query-regular]]
== Regular Custom Query Example

[source,java]
----
    // Creating an expression "firsName is equal to John"
    Qualifier firstNameEqJohn = Qualifier.builder() // Regular qualifier
        .setPath("firstName")
        .setFilterOperation(FilterOperation.EQ)
        .setValue("John")
        .build();
    result = repository.findUsingQuery(new Query(firstNameEqJohn));
    assertThat(result).containsOnly(john);

----

[[custom-query-id]]
== ID Custom Query Example

[source,java]
----
    // Creating an expression "primary key is equal to person's id"
    Qualifier keyEqJohnsId = Qualifier.idEquals(john.getId()); // Id qualifier
    result = repository.findUsingQuery(new Query(keyEqJohnsId));
    assertThat(result).containsOnly(john);

----

[[custom-query-metadata]]
== Metadata Custom Query Example

[source,java]
----
    // creating an expression "since_update_time metadata value is less than 50 seconds"
    Qualifier sinceUpdateTimeLt50Seconds = Qualifier.metadataBuilder() // Metadata qualifier
        .setMetadataField(SINCE_UPDATE_TIME)
        .setFilterOperation(FilterOperation.LT)
        .setValue(50000L)
        .build();
    result = repository.findUsingQuery(new Query(sinceUpdateTimeLt50Seconds));
    assertThat(result).contains(john);

    // expressions are combined using AND
    result = repository.findUsingQuery(new Query(Qualifier.and(firstNameEqJohn, keyEqJohnsId, sinceUpdateTimeLt50Seconds)));
    assertThat(result).containsOnly(john);

----

[[custom-query-dsl-expression]]
== DSL expression Custom Query Example

[source,java]
----
    // DSL expression qualifier
    Qualifier firstNameAndAge = Qualifier.dslExpressionBuilder()
            // Using a comprehensive static DSL expression with fixed values
            .setDSLExpressionString("$.firstName == 'Leroi' and $.age >= 25 and $.age < 45")
            .build();
        Query query = new Query(firstNameAndAge);

        // This is full filter expression represented by the DSL string
        assertThat(query.getCriteriaObject().getFilterExpression()).isEqualTo(Exp.build(
            Exp.and(
                Exp.eq(Exp.bin("firstName", Exp.Type.STRING), Exp.val("Leroi")),
                Exp.ge(Exp.bin("age", Exp.Type.INT), Exp.val(25)),
                Exp.lt(Exp.bin("age", Exp.Type.INT), Exp.val(45))
            )
        ));

        Iterable<Person> result = repository.findUsingQuery(new Query(firstNameAndAge));
        assertThat(result).containsExactlyInAnyOrder(leroi, leroi2);

        // It is currently NOT allowed to combine qualifiers if at least one of them is a DSL expression qualifier
        Qualifier firstNameEq = Qualifier.dslExpressionBuilder()
            // Using a comprehensive static DSL expression with fixed values
            .setDSLExpressionString("$.firstName == 'Leroi'")
            .build();
        Qualifier ageBetween = Qualifier.builder()
            .setPath("age")
            .setFilterOperation(FilterOperation.BETWEEN)
            .setValue(25)
            .setSecondValue(45)
            .build();

        assertThatThrownBy(() -> new Query(Qualifier.and(firstNameEq, ageBetween)))
            .isInstanceOf(UnsupportedOperationException.class)
            .hasMessageContaining("Cannot combine DSL expression qualifiers in a custom logical query");

----

[[custom-query-indexed-expression]]
== Indexed Using Expression Custom Query Example

[source,java]
----
            String indexName = "idx_selected_names_above_25";
            // Build an expression that filters age only for adults with expected names that are 25 or older
            Expression filterExpr = Exp.build(
                Exp.cond(
                    Exp.and(
                        Exp.ge( // Is the age 25 or older?
                            Exp.intBin("age"),
                            Exp.val(25)
                        ),
                        ListExp.getByValue( // Do they have the expected names?
                            ListReturnType.EXISTS,
                            Exp.stringBin("firstName"),
                            Exp.val(List.of("Leroi", "Stefan"))
                        )
                    ),
                    Exp.intBin("age"), // If true, return the age of the customer to be indexed
                    Exp.unknown() // Returns "unknown" to exclude the record from the index
                )
            );

            // Create an index using the Expression
            String setName = template.getSetName(Person.class);
            template.createIndex(setName, indexName, IndexType.NUMERIC, IndexCollectionType.DEFAULT, filterExpr);
            assertThat(template.indexExists(indexName)).isTrue();

            // Create the query
            Qualifier usingIndexWithExpression = Qualifier.indexedWithExpressionBuilder()
                .setIndexName(indexName)
                .setFilterOperation(FilterOperation.GT)
                .setValue(25)
                .build();
            Query query = new Query(usingIndexWithExpression);

            // Run the query
            Iterable<Person> result = repository.findUsingQuery(query);
            assertThat(result).containsExactlyInAnyOrder(stefan, leroi);

----

