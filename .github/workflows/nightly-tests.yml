name: Nightly Tests on GCP
permissions:
  contents: read
  actions: write  # Required to upload artifacts

on:
  schedule:
    - cron: '0 0 * * *'  # Run at midnight UTC
  workflow_dispatch:     # Allow manual triggering

jobs:
  check_changes:
    runs-on: ubuntu-latest
    timeout-minutes: 5  # Timeout to check for the changes
    outputs:
      should_run: ${{ steps.check.outputs.changed }}

    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0  # Fetch all history to compare commits

      - name: Check for changes since last successful run
        id: check
        run: |
          # Get the last successful run SHA with error handling
          echo "Fetching last successful run information..."

          # Make API call with error checking
          API_RESPONSE=$(curl -s -f -H "Authorization: token ${{ github.token }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/nightly-tests.yml/runs?status=success&branch=main" || echo "ERROR")

          if [ "$API_RESPONSE" = "ERROR" ]; then
            echo "API call failed, running tests as fallback"
            echo "changed=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Try to extract SHA with error handling
          LAST_SUCCESS_SHA=$(echo "$API_RESPONSE" | jq -r '.workflow_runs[0].head_sha // ""')
          echo "Last successful run SHA: ${LAST_SUCCESS_SHA:-none}"

          # Run tests if API returned no results or invalid data
          if [ -z "$LAST_SUCCESS_SHA" ] || [ "$LAST_SUCCESS_SHA" = "null" ]; then
            echo "No previous successful run found, running tests"
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            # Verify SHA is valid
            if ! git rev-parse --quiet --verify "$LAST_SUCCESS_SHA^{commit}" >/dev/null; then
              echo "Retrieved SHA is not valid, running tests"
              echo "changed=true" >> $GITHUB_OUTPUT
            else
              # Check if there are any new commits since the last successful run
              DIFF=$(git log --oneline $LAST_SUCCESS_SHA..HEAD)
              if [ -n "$DIFF" ]; then
                echo "Changes detected since last successful run"
                echo "changed=true" >> $GITHUB_OUTPUT
              else
                echo "No changes detected since last successful run"
                echo "changed=false" >> $GITHUB_OUTPUT
              fi
            fi
          fi

  test:
    needs: check_changes
    if: ${{ needs.check_changes.outputs.should_run == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    timeout-minutes: 60  # Timeout for the entire job
    env:
      TEST_FOLDERS_TO_KEEP: 20  # Number of test result folders to keep
      REQUIRED_MAVEN_VERSION: "3.9.0"
      REQUIRED_DOCKER_VERSION: "20.10.0"

    steps:
      - name: Checkout for workflow files only
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v1

      - name: Start GCP VM  # Start VM
        run: |
          gcloud compute instances start ${{ secrets.GCP_VM_NAME }} --zone=${{ secrets.GCP_VM_ZONE }}
          # Wait for VM to fully boot
          sleep 30

      - name: Set up VM prerequisites
        run: |
          # Install Git, JDK 17, Maven, and Docker on the VM if not already installed
          gcloud compute ssh ${{ secrets.GCP_VM_NAME }} --zone=${{ secrets.GCP_VM_ZONE }} --command="
            if ! command -v git &> /dev/null; then
              echo 'Installing Git...'
              sudo apt-get update
              sudo apt-get install -y git
            else
              echo 'Git is already installed'
            fi
          
            # Check for Java
            if ! command -v java &> /dev/null || ! java -version 2>&1 | grep -q 'version \"17'; then
              echo 'Installing JDK 17...'
              sudo apt-get update
              sudo apt-get install -y openjdk-17-jdk
            else
              echo 'JDK 17 is already installed'
            fi

            # Define helper function for version comparison
            version_to_number() {
              local version=\$1
              # Extract major, minor, patch - handling missing components
              local major=\$(echo \$version | cut -d. -f1)
              local minor=\$(echo \$version | cut -d. -f2 2>/dev/null || echo 0)
              local patch=\$(echo \$version | cut -d. -f3 2>/dev/null || echo 0)
          
              # Print as comparable number with zero padding
              printf \"%d%03d%03d\" \"\$major\" \"\$minor\" \"\$patch\"
            }
          
            echo \"Required Maven version: \$REQUIRED_MAVEN_VERSION\"
            REQ_VERSION_INT=\$(version_to_number \"\$REQUIRED_MAVEN_VERSION\")
            echo \"Required Maven numeric: \$REQ_VERSION_INT\"

            # Remove any existing broken Maven installation if present
            if dpkg -l | grep -q maven && ! command -v mvn &> /dev/null; then
              echo \"Found broken Maven installation. Removing it...\"
              sudo apt-get remove -y maven
              sudo apt-get autoremove -y
            fi

            # Check existing Maven version
            if command -v mvn &> /dev/null; then
              MVN_VERSION=\$(mvn --version 2>/dev/null | head -n 1 | awk '{print \$3}' || echo 'unknown')
              echo \"Current Maven version: \$MVN_VERSION\"
          
              # Check if current version meets requirements
              if [ \"\$MVN_VERSION\" != \"unknown\" ]; then
                MVN_VERSION_INT=\$(version_to_number \"\$MVN_VERSION\")
                echo \"Current Maven numeric: \$MVN_VERSION_INT, Required: \$REQ_VERSION_INT\"
          
                if [ \$MVN_VERSION_INT -ge \$REQ_VERSION_INT ]; then
                  echo \"Current Maven \$MVN_VERSION meets requirement\"
                  echo \"Maven binary location: \$(which mvn)\"
                else
                  echo \"Current Maven \$MVN_VERSION does not meet requirement \$REQUIRED_MAVEN_VERSION\"
                  # Need to install newer Maven
                  sudo rm -f \$(which mvn)
                fi
              fi
            else
              echo \"Maven command not found\"
            fi
          
            # If mvn command doesn't exist or version wasn't adequate, install Maven
            if ! command -v mvn &> /dev/null; then
              echo \"Installing Maven from Apache website...\"
              sudo mkdir -p /opt/maven
              cd /tmp
          
              # Try several known versions from newest to oldest
              for VERSION in '3.9.8' '3.9.5' '3.9.4' '3.9.3' '3.9.2' '3.9.1' '3.9.0'; do
                echo \"Trying to install Maven \$VERSION...\"
                wget -q https://archive.apache.org/dist/maven/maven-3/\$VERSION/binaries/apache-maven-\$VERSION-bin.tar.gz
          
                if [ -f apache-maven-\$VERSION-bin.tar.gz ]; then
                  echo \"Downloaded Maven \$VERSION successfully\"
                  sudo tar xzf apache-maven-\$VERSION-bin.tar.gz -C /opt/maven
                  sudo ln -sf /opt/maven/apache-maven-\$VERSION/bin/mvn /usr/local/bin/mvn
          
                  # Verify installation
                  if command -v mvn &> /dev/null; then
                    echo \"Maven \$VERSION installed successfully:\"
                    mvn --version
                    echo \"Maven location: \$(which mvn)\"
                    break  # Success!
                  else
                    echo \"Maven binary not found in path after installation\"
                    # Try creating symlink in another location
                    sudo ln -sf /opt/maven/apache-maven-\$VERSION/bin/mvn /usr/bin/mvn
                    if command -v mvn &> /dev/null; then
                      echo \"Maven \$VERSION installed successfully after symlink fix:\"
                      mvn --version
                      break  # Success!
                    fi
                  fi
                else
                  echo \"Failed to download Maven \$VERSION, trying next version...\"
                fi
              done

              # Last resort: try apt installation
              if ! command -v mvn &> /dev/null; then
                echo \"All Apache downloads failed. Trying apt as last resort...\"
                sudo apt-get update
                sudo apt-get install -y maven
          
                # Verify installation again
                if command -v mvn &> /dev/null; then
                  echo \"Maven installed via apt:\"
                  mvn --version
                else
                  # Try to find the maven binary anywhere on the system
                  echo \"Maven command still not available. Searching for maven binary...\"
                  MAVEN_BIN=\$(find /usr -name mvn 2>/dev/null | head -1 || echo \"\")
          
                  if [ -n \"\$MAVEN_BIN\" ]; then
                    echo \"Found Maven binary at \$MAVEN_BIN\"
                    sudo ln -sf \$MAVEN_BIN /usr/local/bin/mvn
                    echo \"Created symlink to: /usr/local/bin/mvn\"
                    mvn --version
                  else
                    echo \"FATAL: Could not find Maven installation anywhere.\"
                    exit 1
                  fi
                fi
              fi
            fi
          
            # Check for Docker and install if needed
            echo \"Checking Docker installation...\"
          
            # Check if Docker is already installed and running
            DOCKER_RUNNING=false
            if command -v docker &> /dev/null; then
              DOCKER_VERSION=\$(docker --version 2>/dev/null | awk '{print \$3}' | sed 's/,//' || echo 'unknown')
              echo \"Docker version found: \$DOCKER_VERSION\"
          
              # Check Docker version meets requirements
              if [ \"\$DOCKER_VERSION\" != \"unknown\" ]; then
                # Remove leading 'v' if present in version string
                DOCKER_VERSION=\${DOCKER_VERSION#v}
                DOCKER_VERSION_INT=\$(version_to_number \"\$DOCKER_VERSION\")
                REQUIRED_DOCKER_INT=\$(version_to_number \"\$REQUIRED_DOCKER_VERSION\")
          
                echo \"Docker version numeric: \$DOCKER_VERSION_INT, Required: \$REQUIRED_DOCKER_INT\"
          
                if [ \$DOCKER_VERSION_INT -ge \$REQUIRED_DOCKER_INT ]; then
                  echo \"Docker version \$DOCKER_VERSION meets requirement\"
          
                  # Check if Docker daemon is running
                  if sudo docker info &> /dev/null; then
                    echo \"Docker daemon is running.\"
                    DOCKER_RUNNING=true
                  else
                    echo \"Docker is installed but daemon is not running.\"
                  fi
                else
                  echo \"Docker version \$DOCKER_VERSION does not meet minimum requirement \$REQUIRED_DOCKER_VERSION\"
                fi
              fi
            else
              echo \"Docker is not installed\"
            fi
          
            # Install or start Docker if needed
            if [ \"\$DOCKER_RUNNING\" = false ]; then
              if ! command -v docker &> /dev/null; then
                echo \"Installing Docker...\"
                sudo apt-get update
                sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common
          
                # Add Docker's official GPG key
                curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
          
                # Add Docker repository
                sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable\"
          
                # Install Docker
                sudo apt-get update
                sudo apt-get install -y docker-ce docker-ce-cli containerd.io
          
                # Start Docker service
                sudo systemctl enable docker
                sudo systemctl start docker
          
                # Add current user to docker group to allow running docker without sudo
                sudo usermod -aG docker \$USER
              else
                echo \"Starting Docker service...\"
                sudo systemctl start docker
              fi
          
              # Verify Docker installation and daemon
              if sudo docker info &> /dev/null; then
                echo \"Docker installation verified and daemon is running.\"
              else
                echo \"Failed to start Docker daemon. Trying alternative method...\"
                # Try restarting the service
                sudo systemctl restart docker
                sleep 5
          
                if sudo docker info &> /dev/null; then
                  echo \"Docker daemon started successfully after restart.\"
                else
                  echo \"WARNING: Docker daemon still not running. Tests that require Docker may fail.\"
                fi
              fi
            fi
          
            # Test Docker with a simple hello-world container
            echo \"Testing Docker with hello-world container...\"
            sudo docker run --rm hello-world &> /tmp/docker_test_output.txt || true
          
            if grep -q \"Hello from Docker!\" /tmp/docker_test_output.txt; then
              echo \"Docker is working correctly!\"
            else
              echo \"Docker test failed. Output:\"
              cat /tmp/docker_test_output.txt
              echo \"WARNING: Docker may not be functioning correctly. Tests requiring Docker may fail.\"
            fi
          "

      - name: Run tests on VM
        id: run_tests
        timeout-minutes: 45  # Timeout for just the tests run
        run: |
          # Get current timestamp for results directory
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          
          # Create timestamped directory for this test run
          mkdir -p test-results/$TIMESTAMP
          
          # Run commands on the VM to clone repo, set up, and execute tests
          gcloud compute ssh ${{ secrets.GCP_VM_NAME }} --zone=${{ secrets.GCP_VM_ZONE }} --command="
            # Clean up any previous runs
            rm -rf ~/spring_data_repo && mkdir -p ~/spring_data_repo
          
            # Clone the repository
            git clone https://github.com/${{ github.repository }} ~/spring_data_repo
            cd ~/spring_data_repo
            git checkout ${{ github.ref_name }}
          
            # Verify prerequisites are available
            echo \"Verifying prerequisites...\"
          
            if ! command -v mvn &> /dev/null; then
              echo \"ERROR: Maven command not available. Cannot run tests.\"
              exit 1
            fi
            echo \"Using Maven: \$(which mvn)\"
            mvn --version
          
            if ! command -v docker &> /dev/null; then
              echo \"WARNING: Docker command not available. Tests requiring Docker will fail.\"
            else
              echo \"Using Docker: \$(which docker)\"
              docker --version
          
              # Check Docker daemon
              if ! sudo docker info &> /dev/null; then
                echo \"WARNING: Docker daemon is not running. Tests requiring Docker will fail.\"
                sudo systemctl restart docker
                sleep 5
                if ! sudo docker info &> /dev/null; then
                  echo \"CRITICAL: Could not start Docker daemon.\"
                fi
              fi
            fi
          
            # Run tests
            mvn clean test -Pall-tests -B -U
          
            # Save exit code to report success/failure
            echo \$? > ~/test_exit_code
          "
          
          # Copy test results back
          gcloud compute scp --recurse ${{ secrets.GCP_VM_NAME }}:~/spring_data_repo/target/surefire-reports ./test-results/$TIMESTAMP --zone=${{ secrets.GCP_VM_ZONE }} || true
          
          # Implement file rotation - keep only N latest test result directories
          echo "Rotating test result directories, keeping only the $TEST_FOLDERS_TO_KEEP latest"
          ls -t test-results | tail -n +$((TEST_FOLDERS_TO_KEEP + 1)) | xargs -I {} rm -rf test-results/{}
          echo "Current test result directories after rotation:"
          ls -la test-results/
          
          # Check if tests failed
          TEST_EXIT_CODE=$(gcloud compute ssh ${{ secrets.GCP_VM_NAME }} --zone=${{ secrets.GCP_VM_ZONE }} --command="cat ~/test_exit_code || echo 1")
          if [ "$TEST_EXIT_CODE" != "0" ]; then
            echo "Tests failed with exit code $TEST_EXIT_CODE"
            exit 1
          fi

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ github.run_id }}
          path: test-results
          retention-days: 14  # Days to keep artifact

      - name: Stop GCP VM
        if: always()  # Ensure VM is stopped even if tests fail
        run: |
          gcloud compute instances stop ${{ secrets.GCP_VM_NAME }} --zone=${{ secrets.GCP_VM_ZONE }}